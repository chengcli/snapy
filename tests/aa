
  } else if (ab == "W->I") {
    _prim.set_(args[0]);
    _prim2intEng(_prim, _ie);
    return _ie;

void MoistMixtureImpl::_prim2intEng(torch::Tensor prim, torch::Tensor &ie) {
  auto ivol = pthermo->compute(
      "DY->V", {prim[Index::IDN], prim.narrow(0, Index::ICY, ny)});
  auto temp = pthermo->compute("PV->T", {prim[Index::IPR], ivol});
  ie.set_(pthermo->compute("VT->U", {ivol, temp}));
}

  // IE
  _prim2intEng(prim, _ie);
  torch::add_out(cons[Index::IPR], _ke, _ie);

  auto ivol = pthermo->compute(
      "DY->V", {prim[Index::IDN], prim.narrow(0, Index::ICY, ny)});

  torch::sub_out(_ie, cons[Index::IPR], _ke);
